---
layout: post
title: "Concurrence-17-Starvation and Fairness"
description: "翻译 梳理基础的东西"
category: 翻译 java 并发编程 多线程
tags: [翻译 并发编程 多线程]
---
#### Starvation and Fairness
<br/>
##### 饥饿和公平
<br/>

文章的地址：[翻译文章的源地址](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html)
<br/>

如果一个线程因为其他的线程一直占用的CPU时间而没有被分配cpu时间，这种情况称之为饥饿。因为其他的线程一直的占有
CPU的时间，这个线程就会饿死。这个情况的解决办法：公平，所有的线程保证公平获得执行的机会。  

##### java中引起饥饿的原因 

主要有下面三个原因引起饥饿：
1.高优先级的线程吞掉了低优先级的CPU时间      
2.因为一直有其他的线程进入同步款，线程无限期的等待进入synchronized块    
3.其他的线程常被唤醒，这个线程一直等待着

##### 优先级高的线程吞掉优先级低的CPU时间

你可以单独的设置每一个线程的优先级。优先级比较高的线程肯定会比优先级低的获得更加多的时间，线程的优先级可以设置为1
到10，具体是怎么解释这10个优先级取决于你的应用运行在的操作系统。对大多数应用来说，优先级最好是固定的。   

##### 线程在进入synchronized同步块时阻塞

java的synchronized代码块阻塞，也是线程饥饿的一个原因。java的synchronized代码块不能够保证等待在同步代码外的线程
按照一定的顺序进入代码块内。这就意味着有一种可能：某一个线程一直被阻塞在代码块外面，永远的都在尝试着进入代码块内
因为总有其他的线程能够在它之前进入代码块内。这个问题就称为“饥饿”，一个线程可能会因为一直被其他线程占有着CPU，自己
因为分配不到CPU而被饿死。    

##### 线程在一个对象上无限期的等待下去

如果多个线程都调用了一个对象的wait方法，notify方法的调用不能够保证那一个的线程就能够被唤醒。其他的任何线程都在等待
，这个就有一个情况，某一个线程永远的被等待着，因为每次唤醒的都是其他的线程。

#### java中公平的实现



















