---
layout: post
title: redis集群的应用
description: Redis集群的原理，使用的场景
category: Redis集群
tags:
  - Redis集群
---

> 1, Redis Sharding集群 原理，使用的条件，优劣点以及对应的解决方案     


#### redis 集群的解决的方案和原理分析

```
1, Redis Sharding集群
```

Redis Sharding采用客户端Sharding方式，服务端Redis还是一个个相对独立的Redis实例节点，没有做任何变动。理解就是客户端的连接的特定的服务器，但是在增加节点或者删除节点的时候，有一定的兼容的算法，使得原来打在某一个redis实例，还打在这个实例上面。

主要的思想就是根据一定的算法，例如 哈希算法，对Redis的key值进行散列，然后将key值散列到<strong>特定</strong>Redis实例上面。以后的设置，获取等关于该key值的操作，都会打到这个特定的redis实例上面进行操作。

值得庆幸的是，java redis的客户端驱动jedis，已经支持 Redis Sharding 功能。即是ShardedJedis以及结合缓存池ShardedJedisPool。

Jedis的Redis Sharding实现具有如下特点：

> 1.采用一致性哈希算法(consistent hashing)，将key和节点name同时hashing，然后进行映射匹配，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。**一致性哈希只影响相邻节点key分配，影响量小。**<br> 即是：ShardedJedis 在操作的时候，都会调用的getShard方法，来获得key对应的redis实例：

```java
  public R getShard(String key) {
    return resources.get(getShardInfo(key));
  }
  public S getShardInfo(String key) {
    return getShardInfo(SafeEncoder.encode(getKeyTag(key)));
  }
  public String getKeyTag(String key) {
    // 默认的情况下，tagPattern是NULL
    if (tagPattern != null) {
      Matcher m = tagPattern.matcher(key);
      if (m.find()) return m.group(1);
    }
    return key;
  }
  public static byte[] encode(final String str) {
    return str.getBytes(Protocol.CHARSET);
  }
  public S getShardInfo(byte[] key) {
// 最关键的treeMap的数据结构
    SortedMap<Long, S> tail = nodes.tailMap(algo.hash(key));
    if (tail.isEmpty()) {
      return nodes.get(nodes.firstKey());
    }
    return tail.get(tail.firstKey());
  }

  //nodes 是ShardedJedisPool 初始化的时候，hash Redis的实例的配置信息后组成的TreeMap，声明是：   

  private TreeMap<Long, S> nodes;//S extends ShardInfo<R>
```

> 2.为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。根据权重weight，也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各Redis节点移动再分配更均匀，而不是只有相邻节点受影响。

```java
private void initialize(List<S> shards) {
    nodes = new TreeMap<Long, S>();
    for (int i = 0; i != shards.size(); ++i) {
      final S shardInfo = shards.get(i);
      if (shardInfo.getName() == null)
        for (int n = 0; n < 160 * shardInfo.getWeight(); n++) {
          nodes.put(this.algo.hash("SHARD-" + i + "-NODE-" + n), shardInfo);
        }
      else
        for (int n = 0; n < 160 * shardInfo.getWeight(); n++) {
          nodes.put(this.algo.hash(shardInfo.getName() + "*" + shardInfo.getWeight() + n),
              shardInfo);
        }
      resources.put(shardInfo, shardInfo.createResource());
    }
  }
```

> 3.ShardedJedis支持keyTagPattern模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。（默认的情况下为NULL）

KeyTag这个可以在初始化ShardedJedisPool 设置。

```java
public ShardedJedisPool(final GenericObjectPoolConfig poolConfig,
      List<JedisShardInfo> shards, Pattern keyTagPattern) {
        this(poolConfig, shards, Hashing.MURMUR_HASH, keyTagPattern);
  }
```

当然，Redis Sharding这种轻量灵活方式必然在集群其它能力方面做出妥协，但是针对每一种不好的地方，我们又都准备了不同的解决方案。

> 1 扩容，当想要增加Redis节点时，尽管采用一致性哈希，毕竟还是会有key匹配不到而丢失，这时需要键值迁移

这就要求：应用层面允许Redis中数据丢失或从后端数据库重新加载数据。但有些时候，击穿缓存层，直接访问数据库层，会对系统访问造成很大压力。

> 2 轻量级客户端sharding，处理Redis键值迁移比较的麻烦。

Redis作者给出了一个比较讨巧的办法--presharding，即预先根据系统规模尽量部署好多个Redis实例，这些实例占用系统资源很小，一台物理机可部署多个，让他们都参与sharding，当需要扩容时，选中一个实例作为主节点，新加入的Redis节点作为从节点进行数据复制。数据同步后，修改sharding配置，让指向原实例的Shard指向新机器上扩容后的Redis节点，同时调整新Redis节点为主节点，原实例可不再使用。

> 3 应从redis宕机的风险

为不影响Redis性能，尽量不开启AOF和RDB文件保存功能，可采用Redis主备模式，主Redis宕机，数据不会丢失，因为备Redis留有备份。这样，架构模式变成一个Redis节点切片包含一个主Redis和一个备Redis。在主Redis宕机时，备Redis接管过来，上升为主Redis，继续提供服务。主备共同组成一个Redis节点，通过自动故障转移，保证了节点的高可用性。

在保证了高可用的前提下，我们还可以采用读写分离的措施，提高redis的性能：主Redis支持写，从Redis主要支持读的操作。
